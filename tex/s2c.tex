\section{Sign-to-Contract}

\subsection{Syntax \& Correctness}

\begin{definition}[Sign-to-Contract Signature Scheme]
  A sign-to-contract-compatible signature scheme $\algo{SigS2C}$ is a tuple of polynomial-time algorithms $(\algo{Setup}, \algo{KeyGen}, \algo{Sign}, \algo{Verify}, \algo{VerifyCom})$ where:
  \begin{itemize}
    \item $\algo{Setup}(1^\secpar) \rightarrow \params$ is a probabilistic algorithm that takes the security parameter as input and outputs public parameters $\params$ including the message space $\mathcal{M}$, the signature space $\mathcal{S}$, and randomness space $\mathcal{R}$.
    \item $\algo{KeyGen}(\params) \rightarrow (\sk, \pk)$ is a probabilistic algorithm that takes public parameters $\params$ as input and outputs a secret key $\sk$ and a public key $\pk$.
    \item $\algo{Sign}(\params, \sk, m, m_C) \rightarrow (\sigma, r_C)$ is a probabilistic algorithm that takes public parameters $\params$, a secret key $\sk$, message $m \in \mathcal{M}$, and a message $m_C \in \{0, 1\}^*$ as input and outputs a signature $\sigma \in \mathcal{S}$ that commits to $m_C$ and randomness $r_C$.
    \item $\algo{Verify}(\params, \pk, m, \sigma) \rightarrow \{0, 1\}$ is a deterministic algorithm that takes public parameters $\params$, a public key $\pk$, a message $m \in \mathcal{M}$, and a signature $\sigma \in \mathcal{S}$ as input and outputs $1$ (accept) if the signature is valid, and outputs $0$ (reject) otherwise.
    \item $\algo{VerifyCom}(\params, \sigma, m_C, r_C) \rightarrow \{0, 1\}$ is a deterministic algorithm that takes public parameters $\params$, a signature $\sigma \in \mathcal{S}$, a message $m_C$ and randomness $r_C$ as input and outputs $1$ (accept) if the commitment commits to $m_C$ with randomness $r_C$, and outputs $0$ (reject) otherwise.
  \end{itemize}
\end{definition}

\begin{definition}[Correctness]\label{def:s2c-correctness}
  A sign-to-contract-compatible signature scheme $\algo{SigS2C} = (\algo{Setup}, \algo{KeyGen}, \algo{Sign}, \algo{Verify}, \algo{VerifyCom})$ is \emph{correct} if for all $\secpar \in \NN$, all $\params \in \algo{Setup}(1^\secpar)$, all $(\sk, \pk) \in \algo{KeyGen}(\params)$, all messages $m \in \mathcal{M}$ and $m_C \in \{0, 1\}^*$:
  \[
    \Pr\left[
    \begin{array}{c}
      \algo{Verify}(\params, \pk, m, \sigma) = 1 \\
      \wedge \\
      \algo{VerifyCom}(\params, \sigma, m_C, r_C) = 1
    \end{array}
    \middle|
    \begin{array}{c}
      (\sigma, r_C) \gets \\
      \algo{Sign}(\params, \sk, m, m_C)
    \end{array}
    \right] = 1
  \]
  where the probability is taken over the randomness of $\algo{Sign}$.
\end{definition}

\subsection{Security}

\begin{definition}[EUF-CMA Security for Sign-to-Contract]\label{def:euf-cma-s2c}
  A sign-to-contract signature scheme $\algo{SigS2C}$ is \emph{existentially unforgeable under chosen message attack (EUF-CMA)} if for all \ppt adversaries $\adv$:
  \[
    \advantage{EUF-CMA}{\adv, \algo{SigS2C}} \defeq \pr{\game{\Game~\algo{EUF-CMA}}{\algo{SigS2C}} = 1} = \negl
  \]
  where $\game{\Game~\algo{EUF-CMA}}{\algo{SigS2C}}$ is defined in \autoref{fig:euf-cma-s2c}.
\end{definition}

\begin{figure}[tbh]
  \begin{tcolorbox}
    \begin{pchstack}[center]
      \procedure{$\game{\Game~\algo{EUF-CMA}}{\algo{SigS2C}}$}{%
        \params \gets \algo{Setup}(1^\secpar) \\
        (\sk,\pk) \gets \algo{KeyGen}(\params) \\
        \mathcal{Q} \defeq \emptyset\\
        (m^*, \sigma^*) \gets \adv^{\pcoracle{S2CSign}}(\params, \pk) \\
        \pcreturn m^* \notin \mathcal{Q} \wedge \\
        \t \algo{Verify}(\params, \pk, m^*, \sigma^*) = 1
      }
      \pchspace
      \procedure{Oracle $\pcoracle{S2CSign}(m, m_C)$}{%
        (\sigma, r_C) \gets \algo{Sign}(\params, \sk, m, m_C) \\
        \mathcal{Q} \defeq \mathcal{Q} \cup \{m\} \\
        \pcreturn (\sigma, r_C)
      }
    \end{pchstack}
  \end{tcolorbox}
  \caption{The EUF-CMA security game for sign-to-contract signatures}
  \label{fig:euf-cma-s2c}
\end{figure}

\begin{definition}[Commitment Binding for Sign-to-Contract]\label{def:euf-cma-s2c}
\end{definition}

% TODO: commitment binding and hiding !

\subsection{Schnorr Signature with Sign-to-Contract}

\begin{definition}[Schnorr Signature Scheme with Sign-to-Contract]\label{def:schnorr-s2c}
  Let $\grgen$ be a group generation algorithm, $\algo{H}_{\mathsf{sig}}$ be a hash function with output space $\ZZ_p$ for signatures, and $\algo{H}_{\mathsf{com}}$ be a hash function with output space $\ZZ_p$ for commitments. The Schnorr sign-to-contract signature scheme $\algo{SchnorrS2C}[\grgen, \algo{H}_{\mathsf{sig}}, \algo{H}_{\mathsf{com}}]$ is defined as follows:
  \begin{itemize}
    \item $\algo{Setup}(1^\secpar) \rightarrow \params$: Run $\gparam \gets \grgen(1^\secpar)$, $\kappa_{\mathsf{sig}} \gets \algo{H}_{\mathsf{sig}}.\algo{Gen}(1^\secpar)$, and $\kappa_{\mathsf{com}} \gets \algo{H}_{\mathsf{com}}.\algo{Gen}(1^\secpar)$. The message space is $\mathcal{M} = \{0,1\}^*$ and the signature space is $\mathcal{S} = \GG \times \ZZ_p$. Output $\params = (\gparam, \kappa_{\mathsf{sig}}, \kappa_{\mathsf{com}}, \mathcal{M}, \mathcal{S})$.
    
    \item $\algo{KeyGen}(\params) \rightarrow (\sk, \pk)$: Sample $x \sample \ZZ_p$. Compute $X = g^x$. Output $\sk = x$ and $\pk = X$.
    
    \item $\algo{Sign}(\params, \sk, m, m_C) \rightarrow (\sigma, r_C)$: Parse $\params = (\gparam, \kappa_{\mathsf{sig}}, \kappa_{\mathsf{com}}, \mathcal{M}, \mathcal{S})$ and $\sk = x$. Compute:
    \begin{align*}
      r_C &\sample \ZZ_p\\
      R_C &= g^{r_C} \\
      r &= r_C + \algo{H}_{\mathsf{com}}.\algo{Eval}(\kappa_{\mathsf{com}}, (R_C, m_C))  \bmod p\\
      R &= g^r \\
      c &= \algo{H}_{\mathsf{sig}}.\algo{Eval}(\kappa_{\mathsf{sig}}, (R, m)) \\
      s &= r + c \cdot x \bmod p
    \end{align*}
    Output $\sigma = (R, s)$ and $R_C$.
    
    \item $\algo{Verify}(\params, \pk, m, \sigma) \rightarrow \{0, 1\}$: Parse $\params = (\gparam, \kappa_{\mathsf{sig}}, \kappa_{\mathsf{com}}, \mathcal{M}, \mathcal{S})$, $\pk = X$ and $\sigma = (R, s)$. Compute $c = \algo{H}_{\mathsf{sig}}.\algo{Eval}(\kappa_{\mathsf{sig}}, (R, m))$. Accept if and only if:
    \[
      g^s = R \cdot X^c
    \]
  \end{itemize}
\end{definition}

\begin{theorem}[Schnorr signatures with sign-to-contract are EUF-CMA secure]\label{thm:schnorr-s2c-euf-cma}
  Let $\grgen$ be a group generation algorithm for which the discrete logarithm problem is hard and let $\algo{H}_{\mathsf{sig}}$ and $\algo{H}_{\mathsf{com}}$ be hash functions with output space $\ZZ_p$.
  Then the Schnorr signature with sign-to-contract scheme $\algo{SchnorrS2C}[\grgen, \algo{H}_{\mathsf{sig}}, \algo{H}_{\mathsf{com}}]$ is EUF-CMA secure in the random oracle model for $\algo{H}_{\mathsf{sig}}$ and $\algo{H}_{\mathsf{com}}$.
  More precisely, for any \ppt adversary $\adv$ against the EUF-CMA security of $\algo{SchnorrS2C}[\grgen, \algo{H}_{\mathsf{sig}}, \algo{H}_{\mathsf{com}}]$ making at most $q_s$ queries to the signing oracle, at most $q_{h_s}$ queries to the random oracle $\algo{H}_{\mathsf{sig}}$ and at most $q_{h_c}$ queries to the random oracle $\algo{H}_{\mathsf{com}}$,
  there exists a \ppt adversary $\bdv$ against the EUF-CMA security of $\algo{SchnorrSig}[\grgen, \algo{H}_{\mathsf{sig}}]$ making at most $q_s$ queries to the signing oracle and at most $q_{h_s}$ queries to the random oracle $\algo{H}_{\mathsf{sig}}$ such that
  \[
    \advantage{EUF-CMA}{\adv, \algo{SchnorrS2C}[\grgen, \algo{H}_{\mathsf{sig}}, \algo{H}_{\mathsf{com}}]} \leq \advantage{EUF-CMA}{\bdv, \algo{SchnorrSig}[\grgen, \algo{H}_{\mathsf{sig}}]} + q_s \frac{q_s + q_{h_C}}{2^{\secpar - 1}}.
  \]
\end{theorem}


\begin{proof}
  Let $\adv$ be a \ppt adversary against the EUF-CMA security of $\algo{SchnorrS2C}[\grgen, \algo{H}_{\mathsf{sig}}, \algo{H}_{\mathsf{com}}]$  making at most $q_s$ queries to the signing oracle, at most $q_{h_s}$ queries to the random oracle $\algo{H}_{\mathsf{sig}}$ and at most $q_{h_c}$ queries to the random oracle $\algo{H}_{\mathsf{com}}$.

  \begin{enumerate}
  \item Let $\bdv$ be the adversary as defined in \autoref{fig:schnorr-s2c-reduction} that internall runs $\adv$.
  \item Let $E$ be the event that during a $\pcoracle{S2CSign}$ query, $\algo{H}_{\mathsf{com}}$ had already been queried with $R_C, m_C$.
  \item Claim: Then \[
      \pr{\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrS2C}} = 1 \wedge \neg E} =  \pr{\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrSig}}[\bdv] = 1 \wedge \neg E}
  \]
  \begin{enumerate}
    \item In both games, the inputs of $\adv$ have the same distribution. The only change is in oracle $\pcoracle{S2CSign}$.
  \item In both games $\sigma$ is a valid Schnorr signature.
    In particular, in $\bdv$ it is just the output of $\pcoracle{Sign}$.
  \item In \bdv, we have $R_C = R g^{-c}$ where $c = \algo{H}_{\mathsf{com}}(R_C, m_C)$.
    Therefore, $R = R_C \cdot g^{c}$ for for signature $(R, s) = \sigma$.
  \end{enumerate}
  \item $\pr{E} = q_s \frac{q_s + q_{h_C}}{2^{\secpar - 1}}$
    \begin{enumerate}
      \item Let $E_i$ be the event that the assertion is triggered in the $i-th$ call to $\pcoracle{SignS2C}$.
      \item At any call to $\pcoracle{SignS2C}$, the table $T$ has at most $q_s + q_{h_c}$ entries.
      \item Since $c$ is distributed uniformly at random in $\ZZ_p$, $R_C$ is distributed uniformly at random in $\GG$.
        If $E_i$ happens then there exists $R_C'$ in $T$ such that $R_C = R_C'$. Thus,
        \begin{align*}
          \pr{E_i} &\leq \frac{q_s + q_{h_C}}{|\GG|} \\
                   &\leq \frac{q_s + q_{h_C}}{2^{\secpar - 1}}
        \end{align*}
        where we used the fact that $|\GG| \ge 2^{\secpar - 1}$.
      \item We have
        \begin{align*}
          \pr{E} &= \pr{E_0 \vee \ldots \vee E_{q_s}}\\
           &\le \pr{E_0} + \ldots + \pr{E_{q_s}} \\
           &\le q_s \frac{q_s + q_{h_C}}{2^{\secpar - 1}} \\
        \end{align*}
    \end{enumerate}
  \item Using the difference lemma, we have
    \[
    | \pr{\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrS2C}} = 1} - \pr{\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrSig}}[\bdv] = 1}| \le q_s \frac{q_s + q_{h_C}}{2^{\secpar - 1}}.
      \]
      Thus,
    \[
    \pr{\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrS2C}} = 1} \le \pr{\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrSig}}[\bdv] = 1} + q_s \frac{q_s + q_{h_C}}{2^{\secpar - 1}}.
      \]
  \end{enumerate}
  It is easy to see that $\bdv$ is \ppt (if $\adv$ is \ppt).
  $\bdv$ makes no more than $q_s$ queries to $\pcoracle{Sign}$ and $q_{h_s}$ queries to $\algo{H}_{\mathsf{sig}}$.
\end{proof}


\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=\textwidth]
      \begin{pchstack}[center]
        \begin{pcvstack}
          \procedure[headlinesep=1pt]{$\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrS2C}}$}{%
            \gparam \gets \grgen(1^\secpar) \\
            x \sample \ZZ_p \\
            X \defeq g^x \\
            \params \defeq (\gparam, \{0,1\}^*, \GG \times \ZZ_p) \\
            T_{\mathsf{sig}} \defeq \emptyset \\
            T_{\mathsf{com}} \defeq \emptyset \\
            \mathcal{Q} \defeq \emptyset \\
            (m^*, \sigma^*) \gets \adv^{\pcoracle{S2CSign}, \pcoracle{H}_{\mathsf{sig}}, \pcoracle{H}_{\mathsf{com}}}(\params, X) \\
            (R^*, s^*) \defeq \sigma^* \\
            c^* \defeq \pcoracle{H}_{\mathsf{sig}}((R^*, m^*)) \\
            \pcreturn m^* \notin \mathcal{Q} \wedge g^{s^*} = R^* \cdot X^{c^*}
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{S2CSign}(m, m_C)$}{%
            r_C \sample \ZZ_p \\
            R_C \defeq g^{r_C} \\
            r \defeq r_C + \pcoracle{H}_{\mathsf{com}}((R_C, m_C)) \\
            R \defeq g^r \\
            c \defeq \pcoracle{H}_{\mathsf{sig}}((R, m)) \\
            s \defeq r + c \cdot x \bmod p \\
            \mathcal{Q} \defeq \mathcal{Q} \cup \{m\} \\
            \pcreturn ((R, s), R_C)
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{H}_{\mathsf{sig}}(y)$}{%
            \pcif T_{\mathsf{sig}}[y] = \bot \pcthen \\
            \t T_{\mathsf{sig}}[y] \sample \ZZ_p \\
            \pcreturn T_{\mathsf{sig}}[y]
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{H}_{\mathsf{com}}(y)$}{%
            \pcif T_{\mathsf{com}}[y] = \bot \pcthen \\
            \t T_{\mathsf{com}}[y] \sample \ZZ_p \\
            \pcreturn T_{\mathsf{com}}[y]
          }
        \end{pcvstack}
        \pchspace
        \begin{pcvstack}
          \procedure[headlinesep=1pt]{$\bdv^{\pcoracle{H}_{\mathsf{sig}}}(\gamechange{$\gparam, X$})$}{%
            \gamechange{$\params \defeq (\gparam, \{0,1\}^*, \GG \times \ZZ_p)$} \\
            T_{\mathsf{com}} \defeq \emptyset \\
            \gamechange{$\pcreturn \adv^{\pcoracle{S2CSign}_{\bdv}, \pcoracle{H}_{\mathsf{sig}}, \pcoracle{H}_{\mathsf{com},\bdv}}(\params, X)$}
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{S2CSign}_{\bdv}(m, m_C)$}{%
            \gamechange{$\sigma \gets \pcoracle{Sign}(m)$}\\
            \gamechange{$c \sample \ZZ_p$}\\
            \gamechange{$(R, s) \gets \sigma$}\\
            \gamechange{$R_C := R \cdot g^{-c}$}\\
            \gamechange{$\pcassert T_{\mathsf{com}}[R_C, m_C] = \bot$} \\
            \gamechange{$T_{\mathsf{com}}[R_C, m_C] := c$}\\
            \gamechange{$\pcreturn (\sigma, R_C)$}\\
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{H}_{\mathsf{com},\bdv}(y)$}{%
            \pcif T_{\mathsf{com}}[y] = \bot \pcthen \\
            \t T_{\mathsf{com}}[y] \sample \ZZ_p \\
            \pcreturn T_{\mathsf{com}}[y]
          }
        \end{pcvstack}
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Security reduction for Schnorr sign-to-contract signatures: EUF-CMA game (left), algorithm $\bdv$ (middle), and algorithm $\cdv$ (right). Changes from the previous game are marked with $\gamechange{$\cdot$}$.}
  \label{fig:schnorr-s2c-reduction}
\end{figure}




