\section{Introduction}\label{sec:intro}

The concepts introduced in this section may at first seem abstract, but this level of abstraction is important: it provides the rigorous mathematical framework on which modern provable cryptography is built.
Throughout this workbook we will study algorithms, analyse their running time and success probability, both for explicit algorithms and for hypothetical adversarial algorithms.
In later sections we will sometimes study these algorithms within idealised computational models.

This workbook primarily contains definitions, propositions, and lemmas, with limited intuitive explanations.
Good cryptography papers should include intuition, but it's never complete---intuition is inherently subjective and what makes sense to one reader may not resonate with another.
What you need to do is develop your own explanations while reading the mathematics very precisely.
The goal of this workbook is to build intuition step-by-step through the exercises, which provide hands-on experience with the theoretical concepts.

Note that there is rarely a single standard definition for a concept in cryptography.
Sometimes we encounter equivalent definitions in the literature, while other times we find definitions that differ in subtle but important ways.
This is why contemporary papers in cryptography include a preliminaries section that rigorously defines the concepts they use.

This workbook may contain a lot of mistakes.
There's a bounty of 50 sats (paid out via the Lightning Network) per mistake found once this document is published.

% NOTE: What we're doing is similar to applied physics. I would like to promise that we're just doing algorithms. who has had a course in theoretical computer science or algorithms?
% what we're not going to do

% REQUIREMENTS:
% basic sets
% proof by contraposition
% union bound
% what is big-O notation, set builder notation
% good to have seen before:
% negligible functions
% p.p.t. algorithms

TODO: dummy cite something to make biber happy \textcite{EPRINT:NicRufSeu20}.

\subsection{Algorithms}

\say{In mathematics, \emph{algorithm} is commonly understood to be an exact prescription, defining a computational process, leading from various initial data to the desired result.} (A. Markov, 1954)

\begin{definition}
An algorithm $\adv$ is
\begin{itemize}
\item \emph{polynomial-time} if there exists a polynomial $p$ such that for every $x \in \{0,1\}^\lambda$, $\adv(x)$ terminates in time $p(\lambda)$.
\item \emph{probabilistic} if it has access to a source of randomness.
\item \emph{probabilistic polynomial-time (PPT)} if it is probabilistic and polynomial-time.
\end{itemize}
\end{definition}

Note that the runtime of an algorithm is characterized by the size of the input.
Unless stated otherwise, an adversary is a synonym for algorithm.

\subsection{Negligible Functions}



\begin{definition}
A function $f: \ZZ \rightarrow \real$ is \emph{negligible} if for every polynomial $p$ there exists $N \in \NN$ such that for all integers $\secpar > N$, $f(\secpar) \le \frac{1}{p(\secpar)}$.
% Or equivalently.
% - We denote the set of \emph{polynomially-bounded} functions in the security parameter $\secpar$ by $\poly = \{ f : \exists a \in \NN,\ f(\secpar) \in O(\lambda^a) \}$,. functions in the security parameter $\secpar$ by $\negl = \{ f : f(\secpar)^{-1} \not\in \poly \}$
% - for all $a \in \NN$, there exists $N \in \NN$ such that for all $\secpar \ge N$, $f(\secpar) \le \frac{1}{\lambda^a}$.
\end{definition}

\begin{example}
  $2^{-\secpar}$ and $2^{-\sqrt{\secpar}}$ are negligible. $1/\secpar$ is not negligible.
\end{example}

If a function $f$ is negligible, we write $f(\secpar) = \negl$.


\begin{proposition}
  \label{lem:negl}
  \hfill
  \begin{enumerate}
  \item Let $f$ be a negligible function and $p$ be a polynomial. Then $f(\secpar) \cdot p(\secpar)$ is negligible.
  \item Let $f_1, f_2$ be negligible functions. Then $f_1 + f_2$ is negligible.
  \item Let $f$ be a negligible function $f(\secpar) \ge 0$ and $c > 0$ be a constant. Then $f + c$ is not negligible.
  \item Let $f$ be a non-negligible function and $g$ be a negligible function. Then $f - g$ is not negligible.
  \end{enumerate}
\end{proposition}
\begin{proof}
  \hfill
  \begin{enumerate}
  \item Let $a'$ be an integer such that $p(\lambda) < \lambda^{a'}$ and let $a$ be an arbitrary integer.
    There exists $N \in \NN$ such that for all $\secpar \ge N$, $f(\secpar) \le \frac{1}{\lambda^{a' + a}}$.
    Therefore, $f(\secpar) \cdot p(\secpar) \le \frac{p(\secpar)}{\lambda^{a' + a}} \le \frac{1}{\lambda^{a}}$ for all $\secpar \ge N$.
  \item Let $a \in \NN$ be arbitrary.
    There exists $N_1, N_2 \in \NN$ such that
    \[
    \forall \secpar \ge N_1, f_1(\secpar) \le \frac{1}{\lambda^{a+1}} \quad \text{and} \quad \forall \secpar \ge N_2, f_2(\secpar) \le \frac{1}{\lambda^{a+1}}
    \].
    Let $N = \max(N_1, N_2, 2)$. Then for all $\secpar \ge N$
    \[
      f_1(\secpar) + f_2(\secpar) \le \frac{1}{\lambda^{a+1}} + \frac{1}{\lambda^{a+1}} = \frac{2}{\lambda^{a+1}} \le \frac{1}{\lambda^{a}}.
    \]
  \item Let $c'$ be a constant $c' > \frac{1}{c}$.
    Then $c > c'^{-1}$ and $f(\secpar) + c > c'^{-1}$ for all $\secpar$.
  \item Assume for contradiction that $f - g$ is negligible.
    Then by the above, $f = (f - g) + g$ is negligible, a contradiction.
  \end{enumerate}
\end{proof}

\subsection{Games \& Asymptotic Security}

In this section we will introduce the concept of security games (also called "experiments") and asymptotic security through a series of toy examples.
% THere are other frameworks such as "concrete" security and UC

The $\game{\Game~\algo{Guess}}{}$ defined in \autoref{fig:guessing-game} takes an algorithm $\adv$ and the security parameter $\secpar$ as input and outputs $\pctrue$ or $\pcfalse$.
The game first sets $n = 2^\lambda$ and samples $x$ uniformly at random from $\ZZ_n$.
Then it runs algorithm $\adv$, sets the output to $x'$ and returns $x = x'$.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=3cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\game{\Game~\algo{Guess}}{}$}{%
            n := 2^\lambda\\
            x \sample \ZZ_n \\
            x' \gets \adv() \\
            \pcreturn x = x'
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Guessing game\label{fig:guessing-game}}
\end{figure}

\begin{definition}[Guessing game advantage]
  For $\game{\Game~\algo{Guess}}{}$ as defined in \autoref{fig:guessing-game} we define the advantage of algorithm $\adv$ as
 \[
  \advantage{Guess}{\adv} \defeq \pr{\game{\algo{Guess}}{} = \pctrue}.
 \]
\end{definition}

\begin{proposition}
  For any algorithm $\adv$, $\advantage{Guess}{\adv} = \negl$.
\end{proposition}

\begin{proof}
Let $x'$ be the value returned by $\adv$.
The probability that $x$ sampled uniformly at random from $[1, 2^\lambda]$ is equal to $x'$ is $2^-\lambda = \negl$.
\end{proof}

The $\game{\Game~\algo{SHAPreimgZ}}{}$ defined in \autoref{fig:sha-preimg-0} outputs $\pctrue$ if the algorithm $\adv$ outputs a preimage of 0 under the hash function $\algo{SHA256}: \{0, 1\}^* \rightarrow \{0, 1\}^{256}$.
Note that $\adv$ gets $1^{\secpar}$ (a string of 1s of length $\secpar$) as input in order to characterise the running time of $\adv$ as a function of the security parameter $\secpar$.

% What does this mean? We can make the probability as close to 0 as we want by increasing the security parameter.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\game{\Game~\algo{SHAPreimgZ}}{}$}{%
            y := 0 \\
            x \gets \adv(\secparam) \\
            \pcreturn \algo{SHA256}(x) = y
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding SHA256 preimage of zero \label{fig:sha-preimg-0}}
\end{figure}

\begin{proposition}
 For $\game{\Game~\algo{SHAPreimgZ}}{}$ as defined in \autoref{fig:sha-preimg-0}, let the advantage of $\adv$ be defined as
 \[
  \advantage{SHAPreIZ}{\adv} \defeq \pr{\game{\algo{SHAPreimgZ}}{} = \pctrue}.
 \]
 Assuming there exists $x$ such that $\algo{SHA256}(x) = 0$, there exists a p.p.t algorithm $\adv$ such that
  \[
  \advantage{SHAPreIZ}{\adv} = 1.
  \]
\end{proposition}

\begin{proof}
  Let $\adv$ be an algorithm
  \[
   \pcreturn x
  \]
  where $SHA256(x) = y$.
\end{proof}

In $\game{\Game~\algo{SHAPreimg}}{}$ defined in \autoref{fig:sha-preimg} the value $x$ is a uniformly random bitstring of length $256$.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\game{\Game~\algo{SHAPreimg}}{}$}{%
            x \sample \{0, 1\}^{256}\\
            y \gets \algo{SHA256}(x) \\
            x' \gets \adv(y) \\
            \pcreturn \algo{SHA256}(x') = y
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding the SHA256 preimage of a random value \label{fig:sha-preimg}}
\end{figure}

\begin{proposition}
 For $\game{\Game~\algo{SHAPreimg}}{}$ as defined in \autoref{fig:sha-preimg}, let the advantage of $\adv$ be defined as
 \[
  \advantage{SHAPreI}{\adv} \defeq \pr{\game{\algo{SHAPreimg}}{} = \pctrue}.
 \]
 There exists a p.p.t algorithm $\adv$ such that
 \[
 \advantage{SHAPreI}{\adv} = 1.
 \]
\end{proposition}

\begin{proof}
  Let $\adv$ be an algorithm that queries $\algo{SHA256}$ until it finds a solution as shown in \autoref{fig:sha-preimg-adv}.
  \begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\adv(y)$}{%
          x := 0 \\
          \pcwhile \algo{SHA256}(x) \neq y \pcdo \\
            \t x := x + 1 \\
          \pcendwhile \\
          \pcreturn x
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Algorithm for finding the SHA256 preimage of a given value \label{fig:sha-preimg-adv}}
  \end{figure}
  $\adv$ will return the correct solution with probability $1$.
  The running time of $\adv$ is a constant independent of the security parameter $\secpar$ and, therefore, $\adv$ is p.p.t.
\end{proof}

% NOTE: This is strange but it captures the idea that anything can be broken if you have enough time.
% There is also an algorithm which just has all preimages of SHA256 hardcoded and stored in order. Then use binary search.

We observe that if the output space of the hash function is independent of the security parameter, then the hash function is not preimage-resistant.

\subsection{Hash Functions}

\begin{definition}[Hash function]
  A \emph{hash function} $\algo{H}$ is a pair of p.p.t. algorithms $(\algo{Gen}, \algo{Eval})$ where
  \begin{itemize}
  \item $\algo{Gen}(\secparam) \rightarrow \kappa$ is a probabilistic algorithm that takes the security parameter $\secparam$ and returns a hashing key $\kappa$ \footnote{We assume $\kappa$ includes $\secparam$ so that $\algo{Eval}$ can run in time polynomial in $\secpar$}.
  \item $\algo{Eval}(\kappa, x) \rightarrow y$ takes the hashing key $\kappa$ and $x\in \{0,1\}^*$ as input outputs a hash $y\in \{0,1\}^{c\lambda}$ for some integer $c > 0$.
  \end{itemize}
\end{definition}

Note that the hashing key $\kappa$ is not secret.
It effectively allows the $\algo{Gen}$ algorithm to select an $\algo{Eval}$ function.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
        \procedure[headlinesep=1pt]{$\game{\Game~\algo{Preimage}}{\algo{H}}$}{%
          \kappa \gets \algo{H.Gen}(\secpar) \\
          x \sample \{0, 1\}^\lambda\\
          y \gets \algo{H.Eval}(\kappa, x) \\
          x' \gets \adv(\kappa, y) \\
          \pcreturn \algo{H.Eval}(\kappa, x') = y
        }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding the preimage of a given value under the hash function \label{fig:break-hash}}
\end{figure}

Similar to the algorithm in \autoref{fig:sha-preimg-adv}, there exists an algorithm that wins $\game{\Game~\algo{Preimage}}{\algo{H}}$ with probability 1 by just evaluates $\algo{H.Eval}$ on fresh inputs until $H\algo{H.Eval}(x) = y$.
However, for adequate hash functions this algorithm runs in time exponential in the security parameter.
Hence, the definition of preimage-resistance only considers p.p.t. adversaries.

\begin{definition}[Preimage-resistance]
  A hash function $\algo{H}$ is \emph{preimage-resistant} if for any p.p.t. algorithm $\adv$,
 \[
  \advantage{PreI}{\adv, \algo{H}} \defeq \pr{\game{\algo{Preimage}}{\algo{H}} = \pctrue} = \negl.
 \]
\end{definition}

% why we cannot hardcode all solutions:
% It could have all possible keys hardcoded in a sorted list and then search through them in $O(log lambda)$ time.
% No that's because of uniformity. we need to show advantage for a specific machine and then vary the lambda.
% well we solved this problem through the correct definition of hash functions.

% TODO: some exercises here?

\section{Reductions}
We use reductions to relate the hardness of various games.
If we can reduce a game $X$ to a game $Y$, then the game $Y$ is at least as hard as $X$.
A reduction is a p.p.t algorithm that wins game $X$ using an algorithm that wins game $Y$.
We illustrate the concept of reductions through a series of examples.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=7cm]
      \begin{pchstack}[center]
        \procedure[headlinesep=1pt]{$\game{\Game~\algo{PreimageEither}}{\algo{H}}$}{%
          \kappa \gets \algo{H.Gen}(\secpar) \\
          y_1, y_2 \sample \{0, 1\}^\lambda\\
          x \gets \adv(\kappa, y_1, y_2) \\
          \pcreturn \algo{H.Eval}(\kappa, x) = y_1 \vee \algo{H.Eval}(\kappa, x) = y_2
        }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding the preimage of either of two given values under the hash function \label{fig:break-hash-either}}
\end{figure}


\begin{definition}
  For $\game{\Game~\algo{PreimageEither}}{\algo{H}}$ as defined in \autoref{fig:break-hash-either} we define the advantage of $\adv$ as
 \[
  \advantage{PreIE}{\adv, \algo{H}} \defeq \pr{\game{\algo{PreimageEither}}{\algo{H}} = \pctrue}.
 \]
\end{definition}

\begin{proposition}
  Let $\algo{H}$ be a hash function. If for all p.p.t. adversaries $\adv$, it holds that
  \[
  \advantage{PreIE}{\adv, \algo{H}} = \negl
  \]
  then $\algo{H}$ is preimage-resistant.
\end{proposition}
\begin{proof}
  We prove the contrapositive statement (which is equivalent to the statement in the proposition):
  If $\algo{H}$ is not preimage-resistant, then there exists a p.p.t. algorithm $\adv$ that wins $\game{\Game~\algo{PreimageEither}}{\algo{H}}$ with non-negligible probability.
  Assume $\algo{H}$ is a hash function $\{0,1\}^* \rightarrow \{0,1\}^{c\lambda}$ for some constant $c$ and is not preimage-resistant, then there exists a p.p.t. algorithm $\adv$ that wins $\game{\Game~\algo{Preimage}}{\algo{H}}$ with non-negligible probability.
  Let $\bdv^\adv_\algo{H}$ be an algorithm that runs $\adv$ and returns its output (see \autoref{fig:break-hash-either-bdv}).
  \begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\bdv^\adv_\algo{H}(\kappa, y_1, y_2)$}{%
            x \gets \adv(\kappa, y_1) \\
            \pcreturn (x, 0)
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Algorithm for finding the preimage of either of two given values under the hash function \label{fig:break-hash-either-bdv}}
  \end{figure}

  Then $\advantage{PreIE}{\bdv^\adv_\algo{H}, \algo{H}} = \advantage{PreI}{\adv, \algo{H}}$ and non-negligible and $\bdv^\adv_\algo{H}$ is p.p.t.
\end{proof}

% Exercise: proof the converse

\begin{proposition}
  Let $\algo{H}$ be a hash function. If $\algo{H}$ is preimage-resistant, then for all p.p.t. adversaries $\adv$, it holds that
  \[
  \advantage{PreIE}{\adv, \algo{H}} = \negl.
  \]
\end{proposition}
\begin{proof}
  We prove the contrapositive statement (which is equivalent to the statement in the proposition):
  If there exists a p.p.t. algorithm $\adv$ that wins $\game{\Game~\algo{PreimageEither}}{\algo{H}}$ with non-negligible probability, then $\algo{H}$ is not preimage-resistant.
  Let $\bdv^\adv_\algo{H}$ be an algorithm as defined in \autoref{fig:break-preimage-bdv} that runs $\adv$ and returns its output.
\end{proof}
\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\bdv^\adv_\algo{H}(\kappa, y)$}{%
            (x_1, x_2) \gets \adv(\kappa, y) \\
            \pcif \algo{H.Eval}(\kappa, x_1) = y \pcthen \\
              \t\pcreturn x_1 \\
            \pcelse \\
              \t\pcreturn x_2
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Algorithm for finding the preimage of either of two given values under the hash function \label{fig:break-preimage-bdv}}
  \end{figure}


\subsection{Collision Resistance}

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=8cm]
      \begin{pchstack}[center]
        \procedure[headlinesep=1pt]{$\game{\Game~\algo{Collision}}{\algo{H}}$}{%
          \kappa \gets \algo{H.Gen}(\secpar) \\
          (x,x') \gets \adv(\kappa) \\
          \pcreturn (x \neq x' \wedge \algo{H.Eval}(\kappa, x) = \algo{H.Eval}(\kappa, x'))
        }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding a collision under the hash function \label{fig:break-hash-collision}}
\end{figure}

\begin{definition}[Collision-resistance]
  Hash function $\algo{H}$ is collision-resistant if for any p.p.t. algorithm $\adv$,
 \[
  \advantage{Coll}{\adv, \algo{H}} \defeq \pr{\game{\algo{Collision}}{\algo{H}} = \pctrue} = \negl.
 \]
\end{definition}

\begin{lemma}
  Let $\algo{H}$ be a collision-resistant hash function. Then $\algo{H}$ is preimage-resistant.
\end{lemma}
\begin{proof}
  We prove the contrapositive statement (which is equivalent to the statement in the proposition):
  If $\algo{H}$ is not preimage-resistant, then there exists a p.p.t. algorithm $\adv$ that wins $\game{\Game~\algo{Preimage}}{\algo{H}}$ with non-negligible probability.
  Let $\bdv^\adv_\algo{H}$ be an algorithm as defined in \autoref{fig:break-hash-preimage-bdv} that runs $\adv$ and returns its output.
  \begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=4cm]
      \begin{pchstack}[center]
        \procedure[linenumbering, headlinesep=1pt]{$\bdv^\adv_\algo{H}(\kappa)$}{%
          x \sample \{0, 1\}^{(c+1)\lambda} \\
          y \defeq \algo{H.Eval}(\kappa, x) \\
          x' \gets \adv(\kappa, y) \\
          \pcassert x \neq x' \label{line:break-hash-preimage-bdv-assert} \\
          \pcreturn (x, x')
        }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Algorithm for finding the preimage of a given value under the hash function \label{fig:break-hash-preimage-bdv}}
  \end{figure}
  If $\adv$ succeeds and $\bdv$ does not abort in \cref{line:break-hash-preimage-bdv-assert}, then $\bdv$ wins game $\game{Collision}{\algo{H}}$, or conversely:

  \begin{align*}
  \pr{\game{Collision}{\algo{H}} = \pcfalse} &= \pr{\game{Preimage}{\algo{H}} = \pcfalse \vee \bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} } \\
  &\le \pr{\game{Preimage}{\algo{H}} = \pcfalse} + \pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} } \\
  \end{align*}
  using union bound.
  Then, by the definition of $\advantage{Coll}{\bdv, \algo{H}}$ and $\advantage{PreI}{\adv, \algo{H}}$ we have
  \begin{align*}
    1 - \advantage{Coll}{\bdv, \algo{H}} &\le 1 - \advantage{PreI}{\adv, \algo{H}} + \pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} }\\
  \end{align*}
  and
  \begin{align*}
    \advantage{Coll}{\bdv, \algo{H}} &\ge \advantage{PreI}{\adv, \algo{H}} - \pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} }.\\
  \end{align*}
  Assume for now that $\pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} } = \negl$ which we will show later.
  Then, since $\advantage{PreI}{\adv, \algo{H}}$ is not negligible and \cref{lem:negl} applies,
  $\advantage{Coll}{\bdv, \algo{H}}$ is not negligible.
  Since $\bdv$ is p.p.t., $\algo{H}$ is not collision-resistant.
  This proves the contrapositive statement.

  We now show that $\pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} } = \negl$.
  Let us denote this event by by $A$.
  Let $B_y$ denote the event that $\algo{H.Eval}(\kappa, x) = y$ and $\Ima \algo{H.Eval}(\kappa, \cdot)$ be the image of $\algo{H.Eval}$ for a fixed $\kappa$, i.e., the set of all output values $\algo{H.Eval}(\kappa, \cdot)$ produces.
  Then, by the law of total probability and the chain rule we have
  \begin{align*}
    \pr{A} &= \sum_{y \in \Ima \algo{H.Eval}(\kappa, \cdot)} \pr{A \wedge B_y} \\
           &= \sum_{y \in \Ima \algo{H.Eval}(\kappa, \cdot)} \pr{B_y} \pr{A \mid B_y}
  \end{align*}
  Let $H^{-1}(y) = \{x \in \{0, 1\}^{(c+1)\lambda} : H(x) = y\}$, i.e., the preimage of $y$.
  Since $x$ is uniformly random from a set of size $2^{(c+1)\lambda}$, the probability $\pr{B_y}$ that $\algo{H.Eval}(\kappa, x) = y$ is $\frac{|\algo{H}^{-1}(y)|} {2^{(c+1)\lambda}}$.
  Also, the probability $\pr{A \mid B_y}$ that the sampled value $x$ matches the adversaries answer $x'$ given that $\algo{H.Eval}(\kappa, x) = y$ is $\frac{1}{|\algo{H}^{-1}(y)|}$.
  Therefore, we have
  \begin{align*}
    \pr{A} &= \sum_{y \in \Ima \algo{H.Eval}(\kappa, \cdot)} \frac{|\algo{H}^{-1}(y)|} {2^{(c+1)\lambda}} \frac{1}{|\algo{H}^{-1}(y)|}  \\
           &= \sum_{y \in \Ima \algo{H.Eval}(\kappa, \cdot)} \frac{1} {2^{(c+1)\lambda}} \\
           &= \frac{|\Ima \algo{H.Eval}(\kappa, \cdot)|} {2^{(c+1)\lambda}} \\
           &\le 2^{-\lambda} \\
  \end{align*}
  which is negligible.
\end{proof}
