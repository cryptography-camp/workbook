\section{Introduction}\label{sec:intro}

The concepts introduced in this section may at first seem abstract, but this level of abstraction is important: it provides the rigorous mathematical framework on which modern provable cryptography is built.
Throughout this workbook we will study algorithms, analyse their running time and success probability, both for explicit algorithms and for hypothetical adversarial algorithms.
In later sections we will sometimes study these algorithms within idealised computational models.

This workbook primarily contains definitions, propositions, and lemmas, with limited intuitive explanations.
Good cryptography papers should include intuition, but it's never complete---intuition is inherently subjective and what makes sense to one reader may not resonate with another.
What you need to do is develop your own explanations while reading the mathematics very precisely.
The goal of this workbook is to build intuition step-by-step through the exercises, which provide hands-on experience with the theoretical concepts.

Note that there is rarely a single standard definition for a concept in cryptography.
Sometimes we encounter equivalent definitions in the literature, while other times we find definitions that differ in subtle but important ways.
This is why contemporary papers in cryptography include a preliminaries section that rigorously defines the concepts they use.

This workbook may contain a lot of mistakes.
There's a bounty of 50 sats (paid out via the Lightning Network) per mistake found once this document is published.

% NOTE: What we're doing is similar to applied physics. I would like to promise that we're just doing algorithms. who has had a course in theoretical computer science or algorithms?
% what we're not going to do

% REQUIREMENTS:
% basic sets
% proof by contraposition
% union bound
% good to have seen before:
% negligible functions
% \ppt algorithms

TODO: dummy cite something to make biber happy \textcite{EPRINT:NicRufSeu20}.

\subsection{Algorithms}

\say{In mathematics, \emph{algorithm} is commonly understood to be an exact prescription, defining a computational process, leading from various initial data to the desired result.} (A. Markov, 1954)

\begin{definition}
An algorithm $\adv$ is
\begin{itemize}
\item \emph{probabilistic} if it gets random bits as input (in addition to its regular input).
We write $\adv(x; \rho)$ to denote running algorithm $\adv$ on input $x$ with randomness $\rho$.
When the randomness is clear from context or unnecessary, we simply write $\adv(x)$.
\item \emph{polynomial-time} if there exists a polynomial $p$ such that for every $x \in \{0,1\}^\lambda$, $\adv(x)$ terminates in time $p(\lambda)$.
\item \emph{probabilistic polynomial-time (\ppt)} if it is probabilistic and polynomial-time.
\end{itemize}
\end{definition}

Note that the runtime of an algorithm is characterized relative to the size of the input.
All adversaries considered in cryptography are algorithms.

\subsection{Negligible Functions}



\begin{definition}
A function $f: \ZZ \rightarrow \mathbb{R}$ is \emph{negligible} if for every polynomial $p$ there exists $N \in \NN$ such that for all integers $\secpar > N$, $f(\secpar) \le \frac{1}{p(\secpar)}$.
% Or equivalently.
% - We denote the set of \emph{polynomially-bounded} functions in the security parameter $\secpar$ by $\poly = \{ f : \exists a \in \NN,\ f(\secpar) \in O(\lambda^a) \}$,. functions in the security parameter $\secpar$ by $\negl = \{ f : f(\secpar)^{-1} \not\in \poly \}$
% - for all $a \in \NN$, there exists $N \in \NN$ such that for all $\secpar \ge N$, $f(\secpar) \le \frac{1}{\lambda^a}$.
\end{definition}

\begin{example}
  $2^{-\secpar}$ and $2^{-\sqrt{\secpar}}$ are negligible. $1/\secpar$ is not negligible.
\end{example}

If a function $f$ is negligible, we write $f(\secpar) = \negl$.


\begin{proposition}
  \label{lem:negl}
  \hfill
  \begin{enumerate}
  \item Let $f$ be a negligible function and $p$ be a polynomial. Then $f(\secpar) \cdot p(\secpar)$ is negligible.
  \item Let $f_1, f_2$ be negligible functions. Then $f_1 + f_2$ is negligible.
  \item Let $f$ be a negligible function $f(\secpar) \ge 0$ and $c > 0$ be a constant. Then $f + c$ is not negligible.
  \item Let $f$ be a non-negligible function and $g$ be a negligible function. Then $f - g$ is not negligible.
  \end{enumerate}
\end{proposition}
\begin{proof}
  \hfill
  \begin{enumerate}
  \item Let $a'$ be an integer such that $p(\lambda) < \lambda^{a'}$ and let $a$ be an arbitrary integer.
    There exists $N \in \NN$ such that for all $\secpar \ge N$, $f(\secpar) \le \frac{1}{\lambda^{a' + a}}$.
    Therefore, $f(\secpar) \cdot p(\secpar) \le \frac{p(\secpar)}{\lambda^{a' + a}} \le \frac{1}{\lambda^{a}}$ for all $\secpar \ge N$.
  \item Let $a \in \NN$ be arbitrary.
    There exists $N_1, N_2 \in \NN$ such that
    \[
    \forall \secpar \ge N_1, f_1(\secpar) \le \frac{1}{\lambda^{a+1}} \quad \text{and} \quad \forall \secpar \ge N_2, f_2(\secpar) \le \frac{1}{\lambda^{a+1}}
    \].
    Let $N = \max(N_1, N_2, 2)$. Then for all $\secpar \ge N$
    \[
      f_1(\secpar) + f_2(\secpar) \le \frac{1}{\lambda^{a+1}} + \frac{1}{\lambda^{a+1}} = \frac{2}{\lambda^{a+1}} \le \frac{1}{\lambda^{a}}.
    \]
  \item Let $c'$ be a constant $c' > \frac{1}{c}$.
    Then $c > c'^{-1}$ and $f(\secpar) + c > c'^{-1}$ for all $\secpar$.
  \item Assume for contradiction that $f - g$ is negligible.
    Then by the above, $f = (f - g) + g$ is negligible, a contradiction.
  \end{enumerate}
\end{proof}

\subsection{Games \& Asymptotic Security}

In this section we will introduce the concept of security games (also called "experiments") and asymptotic security through a series of toy examples.
% THere are other frameworks such as "concrete" security and UC

The $\game{\Game~\algo{Guess}}{}$ defined in \autoref{fig:guessing-game} takes an algorithm $\adv$ and the security parameter $\secpar$ as input and outputs $\pctrue$ or $\pcfalse$.
The game first sets $n = 2^\lambda$ and samples $x$ uniformly at random from $\ZZ_n$.
Then it runs algorithm $\adv$, sets the output to $x'$ and returns $x = x'$.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=3cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\game{\Game~\algo{Guess}}{}$}{%
            n := 2^\lambda\\
            x \sample \ZZ_n \\
            x' \gets \adv() \\
            \pcreturn x = x'
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Guessing game\label{fig:guessing-game}}
\end{figure}

\begin{definition}[Guessing game advantage]
  For $\game{\Game~\algo{Guess}}{}$ as defined in \autoref{fig:guessing-game} we define the advantage of algorithm $\adv$ as
 \[
  \advantage{Guess}{\adv} \defeq \pr{\game{\algo{Guess}}{} = \pctrue}.
 \]
\end{definition}

\begin{proposition}
  For any algorithm $\adv$, $\advantage{Guess}{\adv} = \negl$.
\end{proposition}

\begin{proof}
Let $x'$ be the value returned by $\adv$.
The probability that $x$ sampled independently and uniformly at random from $[1, 2^\lambda]$ is equal to $x'$ is $2^{-\lambda} = \negl$.
\end{proof}

The $\game{\Game~\algo{SHAPreimgZ}}{}$ defined in \autoref{fig:sha-preimg-0} outputs $\pctrue$ if the algorithm $\adv$ outputs a preimage of 0 under the hash function $\algo{SHA256}: \{0, 1\}^* \rightarrow \{0, 1\}^{256}$.
Note that $\adv$ gets $1^{\secpar}$ (a string of 1s of length $\secpar$) as input in order to characterise the running time of $\adv$ as a function of the security parameter $\secpar$.

% What does this mean? We can make the probability as close to 0 as we want by increasing the security parameter.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\game{\Game~\algo{SHAPreimgZ}}{}$}{%
            y := 0 \\
            x \gets \adv(\secparam) \\
            \pcreturn \algo{SHA256}(x) = y
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding SHA256 preimage of zero \label{fig:sha-preimg-0}}
\end{figure}

\begin{proposition}
 For $\game{\Game~\algo{SHAPreimgZ}}{}$ as defined in \autoref{fig:sha-preimg-0}, let the advantage of $\adv$ be defined as
 \[
  \advantage{SHAPreIZ}{\adv} \defeq \pr{\game{\algo{SHAPreimgZ}}{} = \pctrue}.
 \]
 Assuming there exists $x$ such that $\algo{SHA256}(x) = 0$, there exists a \ppt algorithm $\adv$ such that
  \[
  \advantage{SHAPreIZ}{\adv} = 1.
  \]
\end{proposition}

\begin{proof}
  Let $\adv$ be an algorithm
  \[
   \pcreturn x
  \]
  where $SHA256(x) = 0$.
\end{proof}

In $\game{\Game~\algo{SHAPreimg}}{}$ defined in \autoref{fig:sha-preimg} the value $x$ is a uniformly random bitstring of length $256$.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\game{\Game~\algo{SHAPreimg}}{}$}{%
            x \sample \{0, 1\}^{256}\\
            y \gets \algo{SHA256}(x) \\
            x' \gets \adv(y) \\
            \pcreturn \algo{SHA256}(x') = y
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding the SHA256 preimage of a random value \label{fig:sha-preimg}}
\end{figure}

\begin{proposition}
 For $\game{\Game~\algo{SHAPreimg}}{}$ as defined in \autoref{fig:sha-preimg}, let the advantage of $\adv$ be defined as
 \[
  \advantage{SHAPreI}{\adv} \defeq \pr{\game{\algo{SHAPreimg}}{} = \pctrue}.
 \]
 There exists a \ppt algorithm $\adv$ such that
 \[
 \advantage{SHAPreI}{\adv} = 1.
 \]
\end{proposition}

\begin{proof}
  Let $\adv$ be an algorithm that queries $\algo{SHA256}$ until it finds a solution as shown in \autoref{fig:sha-preimg-adv}.
  \begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\adv(y)$}{%
          x := 0 \\
          \pcwhile \algo{SHA256}(x) \neq y \pcdo \\
            \t x := x + 1 \\
          \pcendwhile \\
          \pcreturn x
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Algorithm for finding the SHA256 preimage of a given value \label{fig:sha-preimg-adv}}
  \end{figure}
  $\adv$ will return the correct solution with probability $1$.
  The running time of $\adv$ is a constant independent of the security parameter $\secpar$ and, therefore, $\adv$ is \ppt
\end{proof}

% NOTE: This is strange but it captures the idea that anything can be broken if you have enough time.
% There is also an algorithm which just has all preimages of SHA256 hardcoded and stored in order. Then use binary search.

We observe that if the output space of the hash function is independent of the security parameter, then the hash function is not preimage-resistant.

\subsection{Hash Functions}

\begin{definition}[Hash function]
  A \emph{hash function} $\algo{H}$ is a pair of \ppt algorithms $(\algo{Gen}, \algo{Eval})$ where
  \begin{itemize}
  \item $\algo{Gen}(\secparam) \rightarrow \kappa$ is a probabilistic algorithm that takes the security parameter $\secparam$ and returns a hashing key $\kappa$ \footnote{We assume $\kappa$ includes $\secparam$ so that $\algo{Eval}$ can run in time polynomial in $\secpar$}.
  \item $\algo{Eval}(\kappa, x) \rightarrow y$ takes the hashing key $\kappa$ and $x\in \{0,1\}^*$ as input and outputs a hash $y\in \{0,1\}^{c\lambda}$ for some integer $c > 0$.
  \end{itemize}
\end{definition}

Note that the hashing key $\kappa$ is not secret.
It effectively allows the $\algo{Gen}$ algorithm to select an $\algo{Eval}$ function.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
        \procedure[headlinesep=1pt]{$\game{\Game~\algo{Preimage}}{\algo{H}}$}{%
          \kappa \gets \algo{H.Gen}(\secpar) \\
          x \sample \{0, 1\}^\lambda\\
          y \gets \algo{H.Eval}(\kappa, x) \\
          x' \gets \adv(\kappa, y) \\
          \pcreturn \algo{H.Eval}(\kappa, x') = y
        }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding the preimage of a given value under the hash function \label{fig:break-hash}}
\end{figure}

Similar to the algorithm in \autoref{fig:sha-preimg-adv}, there exists an algorithm that wins $\game{\Game~\algo{Preimage}}{\algo{H}}$ with probability 1 by just evaluates $\algo{H.Eval}$ on fresh inputs until $H\algo{H.Eval}(x) = y$.
However, for adequate hash functions this algorithm runs in time exponential in the security parameter.
Hence, the definition of preimage-resistance only considers \ppt adversaries.

\begin{definition}[Preimage-resistance]
  A hash function $\algo{H}$ is \emph{preimage-resistant} if for any \ppt algorithm $\adv$,
 \[
  \advantage{PreI}{\adv, \algo{H}} \defeq \pr{\game{\algo{Preimage}}{\algo{H}} = \pctrue} = \negl.
 \]
\end{definition}

% why we cannot hardcode all solutions:
% It could have all possible keys hardcoded in a sorted list and then search through them in $O(log lambda)$ time.
% No that's because of uniformity. we need to show advantage for a specific machine and then vary the lambda.
% well we solved this problem through the correct definition of hash functions.

% TODO: some exercises here?

\section{Reductions}
We use reductions to relate the hardness of various games.
If we can reduce a game $X$ to a game $Y$, then the game $Y$ is at least as hard as $X$.
A reduction is a \ppt algorithm that wins game $X$ using an algorithm that wins game $Y$.
We illustrate the concept of reductions through a series of examples.

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=7cm]
      \begin{pchstack}[center]
        \procedure[headlinesep=1pt]{$\game{\Game~\algo{PreimageEither}}{\algo{H}}$}{%
          \kappa \gets \algo{H.Gen}(\secpar) \\
          y_1, y_2 \sample \{0, 1\}^\lambda\\
          x \gets \adv(\kappa, y_1, y_2) \\
          \pcreturn \algo{H.Eval}(\kappa, x) = y_1 \vee \algo{H.Eval}(\kappa, x) = y_2
        }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding the preimage of either of two given values under the hash function \label{fig:break-hash-either}}
\end{figure}


\begin{definition}
  For $\game{\Game~\algo{PreimageEither}}{\algo{H}}$ as defined in \autoref{fig:break-hash-either} we define the advantage of $\adv$ as
 \[
  \advantage{PreIE}{\adv, \algo{H}} \defeq \pr{\game{\algo{PreimageEither}}{\algo{H}} = \pctrue}.
 \]
\end{definition}

\begin{proposition}
  Let $\algo{H}$ be a hash function. If for all \ppt adversaries $\adv$, it holds that
  \[
  \advantage{PreIE}{\adv, \algo{H}} = \negl
  \]
  then $\algo{H}$ is preimage-resistant.
\end{proposition}
\begin{proof}
  We prove the contrapositive statement (which is equivalent to the statement in the proposition):
  If $\algo{H}$ is not preimage-resistant, then there exists a \ppt algorithm $\adv$ that wins $\game{\Game~\algo{PreimageEither}}{\algo{H}}$ with non-negligible probability.
  Assume $\algo{H}$ is a hash function $\{0,1\}^* \rightarrow \{0,1\}^{c\lambda}$ for some constant $c$ and is not preimage-resistant, then there exists a \ppt algorithm $\adv$ that wins $\game{\Game~\algo{Preimage}}{\algo{H}}$ with non-negligible probability.
  Let $\bdv^\adv_\algo{H}$ be an algorithm that runs $\adv$ on random input and returns its output (see \autoref{fig:break-hash-either-bdv}).
  \begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=5cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\bdv^\adv_\algo{H}(\kappa, y_1, y_2)$}{%
            x \gets \adv(\kappa, y_1) \\
            \pcreturn (x, 0)
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Algorithm for finding the preimage of either of two given values under the hash function \label{fig:break-hash-either-bdv}}
  \end{figure}

  Then $\advantage{PreIE}{\bdv^\adv_\algo{H}, \algo{H}} = \advantage{PreI}{\adv, \algo{H}}$ and non-negligible and $\bdv^\adv_\algo{H}$ is \ppt
\end{proof}

% Exercise: proof the converse

\begin{proposition}
  Let $\algo{H}$ be a hash function. If $\algo{H}$ is preimage-resistant, then for all \ppt adversaries $\adv$, it holds that
  \[
  \advantage{PreIE}{\adv, \algo{H}} = \negl.
  \]
\end{proposition}
\begin{proof}
  We prove the contrapositive statement (which is equivalent to the statement in the proposition):
  If there exists a \ppt algorithm $\adv$ that wins $\game{\Game~\algo{PreimageEither}}{\algo{H}}$ with non-negligible probability, then $\algo{H}$ is not preimage-resistant.
  Let $\bdv^\adv_\algo{H}$ be an algorithm as defined in \autoref{fig:break-preimage-bdv} that runs $\adv$ and returns its output.
  
  \begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=6cm]
      \begin{pchstack}[center]
          \procedure[headlinesep=1pt]{$\bdv^\adv_\algo{H}(\kappa, y)$}{%
            y' \sample \{0, 1\}^{\lambda} \\
            b \sample \{0, 1\} \\
            \pcif b = 0 \pcthen \\
            \t x \gets \adv(\kappa, y, y') \\
            \pcelse \\
            \t x \gets \adv(\kappa, y', y) \\
            \pcreturn x
          }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Algorithm for finding the preimage of a given value under the hash function \label{fig:break-preimage-bdv}}
  \end{figure}
  
  Let us analyze the success probability of $\bdv$.
  Define the following events:
  \begin{itemize}
    \item Let $E_1$ be the event that $\algo{H.Eval}(\kappa, x) = y_1$ where $x$ is the output of $\adv(\kappa, y_1, y_2)$
    \item Let $E_2$ be the event that $\algo{H.Eval}(\kappa, x) = y_2$ where $x$ is the output of $\adv(\kappa, y_1, y_2)$
    \item Let $E$ be the event that $\algo{H.Eval}(\kappa, x) \in \{y_1, y_2\}$, i.e., $E = E_1 \vee E_2$
  \end{itemize}
  
  By definition, $\pr{E} = \advantage{PreIE}{\adv, \algo{H}}$ since this is exactly the success probability of $\adv$ in the PreimageEither game.
  
  Note that $E_1$ and $E_2$ are disjoint events (since $x$ cannot simultaneously be a preimage of two different values).
  Therefore, $\pr{E} = \pr{E_1 \vee E_2} = \pr{E_1} + \pr{E_2}$.
  
  In the PreimageEither game, both $y_1$ and $y_2$ are chosen uniformly at random from $\{0,1\}^{\lambda}$ and independently, so by symmetry we have $\pr{E_1} = \pr{E_2}$.
  
  Thus: $\advantage{PreIE}{\adv, \algo{H}} = \pr{E} = \pr{E_1} + \pr{E_2} = 2 \cdot \pr{E_1}$
  
  Therefore: $\pr{E_1} = \frac{1}{2} \cdot \advantage{PreIE}{\adv, \algo{H}}$
  
  In $\bdv$'s execution, when $b = 0$, it calls $\adv(\kappa, y, y')$ and succeeds if the output is a preimage of $y$ (the first argument).
  When $b = 1$, it calls $\adv(\kappa, y', y)$ and succeeds if the output is a preimage of $y$ (now the second argument).
  
  Since $\bdv$ succeeds when either ($b = 0$ and $x$ is a preimage of the first argument) or ($b = 1$ and $x$ is a preimage of the second argument), we have:
  $\advantage{PreI}{\bdv^\adv_\algo{H}, \algo{H}} = \frac{1}{2} \cdot \pr{E_1} + \frac{1}{2} \cdot \pr{E_2} = \frac{1}{2} \cdot \advantage{PreIE}{\adv, \algo{H}}$
  
  Since $\advantage{PreIE}{\adv, \algo{H}}$ is non-negligible and $\bdv^\adv_\algo{H}$ is \ppt, $\algo{H}$ is not preimage-resistant.
\end{proof}


\subsection{Collision Resistance}

\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=8cm]
      \begin{pchstack}[center]
        \procedure[headlinesep=1pt]{$\game{\Game~\algo{Collision}}{\algo{H}}$}{%
          \kappa \gets \algo{H.Gen}(\secpar) \\
          (x,x') \gets \adv(\kappa) \\
          \pcreturn (x \neq x' \wedge \algo{H.Eval}(\kappa, x) = \algo{H.Eval}(\kappa, x'))
        }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Game for finding a collision under the hash function \label{fig:break-hash-collision}}
\end{figure}

\begin{definition}[Collision-resistance]
  Hash function $\algo{H}$ is collision-resistant if for any \ppt algorithm $\adv$,
 \[
  \advantage{Coll}{\adv, \algo{H}} \defeq \pr{\game{\algo{Collision}}{\algo{H}} = \pctrue} = \negl.
 \]
\end{definition}

\begin{lemma}
  Let $\algo{H}$ be a collision-resistant hash function. Then $\algo{H}$ is preimage-resistant.
\end{lemma}
\begin{proof}
  We prove the contrapositive statement (which is equivalent to the statement in the proposition):
  If $\algo{H}$ is not preimage-resistant, then there exists a \ppt algorithm $\adv$ that wins $\game{\Game~\algo{Preimage}}{\algo{H}}$ with non-negligible probability.
  Let $\bdv^\adv_\algo{H}$ be an algorithm as defined in \autoref{fig:break-hash-preimage-bdv} that runs $\adv$ and returns its output.
  \begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=4cm]
      \begin{pchstack}[center]
        \procedure[linenumbering, headlinesep=1pt]{$\bdv^\adv_\algo{H}(\kappa)$}{%
          x \sample \{0, 1\}^{(c+1)\lambda} \\
          y \defeq \algo{H.Eval}(\kappa, x) \\
          x' \gets \adv(\kappa, y) \\
          \pcassert x \neq x' \label{line:break-hash-preimage-bdv-assert} \\
          \pcreturn (x, x')
        }
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Algorithm for finding the preimage of a given value under the hash function \label{fig:break-hash-preimage-bdv}}
  \end{figure}
  If $\adv$ succeeds and $\bdv$ does not abort in \cref{line:break-hash-preimage-bdv-assert}, then $\bdv$ wins game $\game{Collision}{\algo{H}}$, or more precisely:

  \begin{align*}
  \pr{\game{Collision}{\algo{H}} = \pcfalse} &= \pr{\game{Preimage}{\algo{H}} = \pcfalse \vee \bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} } \\
  &\le \pr{\game{Preimage}{\algo{H}} = \pcfalse} + \pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} } \\
  \end{align*}
  using union bound.
  Then, by the definition of $\advantage{Coll}{\bdv, \algo{H}}$ and $\advantage{PreI}{\adv, \algo{H}}$ we have
  \begin{align*}
    1 - \advantage{Coll}{\bdv, \algo{H}} &\le 1 - \advantage{PreI}{\adv, \algo{H}} + \pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} }\\
  \end{align*}
  and
  \begin{align*}
    \advantage{Coll}{\bdv, \algo{H}} &\ge \advantage{PreI}{\adv, \algo{H}} - \pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} }.\\
  \end{align*}
  Assume for now that $\pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} } = \negl$ which we will show later.
  Then, since $\advantage{PreI}{\adv, \algo{H}}$ is not negligible and \cref{lem:negl} applies,
  $\advantage{Coll}{\bdv, \algo{H}}$ is not negligible.
  Since $\bdv$ is \ppt, $\algo{H}$ is not collision-resistant.
  This proves the contrapositive statement.

  We now show that $\pr{\bdv \text{ aborts at \cref{line:break-hash-preimage-bdv-assert}} } = \negl$.
  Let us denote this event by by $A$.
  Let $B_y$ denote the event that $\algo{H.Eval}(\kappa, x) = y$ and $\Ima \algo{H.Eval}(\kappa, \cdot)$ be the image of $\algo{H.Eval}$ for a fixed $\kappa$, i.e., the set of all output values $\algo{H.Eval}(\kappa, \cdot)$ produces.
  Then, by the law of total probability and the definition of conditional probability we have
  \begin{align*}
    \pr{A} &= \sum_{y \in \Ima \algo{H.Eval}(\kappa, \cdot)} \pr{A \wedge B_y} \\
           &= \sum_{y \in \Ima \algo{H.Eval}(\kappa, \cdot)} \pr{B_y} \pr{A \mid B_y}
  \end{align*}
  Let $H^{-1}(y) = \{x \in \{0, 1\}^{(c+1)\lambda} : H(x) = y\}$, i.e., the preimage of $y$.
  Since $x$ is uniformly random from a set of size $2^{(c+1)\lambda}$, the probability $\pr{B_y}$ that $\algo{H.Eval}(\kappa, x) = y$ is $\frac{|\algo{H}^{-1}(y)|} {2^{(c+1)\lambda}}$.
  Also, the probability $\pr{A \mid B_y}$ that the sampled value $x$ matches the adversaries answer $x'$ given that $\algo{H.Eval}(\kappa, x) = y$ is $\frac{1}{|\algo{H}^{-1}(y)|}$.
  Therefore, we have
  \begin{align*}
    \pr{A} &= \sum_{y \in \Ima \algo{H.Eval}(\kappa, \cdot)} \frac{|\algo{H}^{-1}(y)|} {2^{(c+1)\lambda}} \frac{1}{|\algo{H}^{-1}(y)|}  \\
           &= \sum_{y \in \Ima \algo{H.Eval}(\kappa, \cdot)} \frac{1} {2^{(c+1)\lambda}} \\
           &= \frac{|\Ima \algo{H.Eval}(\kappa, \cdot)|} {2^{(c+1)\lambda}} \\
           &\le 2^{-\lambda} \\
  \end{align*}
  which is negligible.
\end{proof}
