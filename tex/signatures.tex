\section{Signatures}\label{sec:signatures}

 Unlike one-time signatures, a digital signature scheme allows signing multiple messages with the same key pair.

\subsection{Syntax}

\begin{definition}[Signature Scheme]
  A signature scheme $\algo{Sig}$ consists of four polynomial-time algorithms:
  \begin{itemize}
    \item $\algo{Setup}(1^\secpar) \rightarrow \params$: The parameter generation algorithm takes the security parameter and outputs public parameters $\params = (\mathcal{M}, \mathcal{S})$ where $\mathcal{M}$ is the message space and $\mathcal{S}$ is the signature space.
    \item $\algo{KeyGen}(\params) \rightarrow (\sk, \pk)$: The key generation algorithm takes the public parameters and outputs a secret key $\sk$ and a public key $\pk$.
    \item $\algo{Sign}(\params, \sk, m) \rightarrow \sigma$: The signing algorithm takes the public parameters, a secret key $\sk$, and a message $m \in \mathcal{M}$, and outputs a signature $\sigma \in \mathcal{S}$.
    \item $\algo{Verify}(\params, \pk, m, \sigma) \rightarrow \{0, 1\}$: The verification algorithm takes the public parameters, a public key $\pk$, a message $m \in \mathcal{M}$, and a signature $\sigma \in \mathcal{S}$, and outputs $1$ (accept) or $0$ (reject).
  \end{itemize}
\end{definition}

\subsection{Correctness}

\begin{definition}[Correctness]\label{def:sig-correctness}
  A digital signature scheme $\algo{Sig} = (\algo{Setup}, \algo{KeyGen}, \algo{Sign}, \algo{Verify})$ is \emph{correct} if for all $\secpar \in \NN$, all $\params \in \algo{Setup}(1^\secpar)$, all $(\sk, \pk) \in \algo{KeyGen}(\params)$, and all messages $m \in \mathcal{M}$:
  \[
    \Pr[\algo{Verify}(\params, \pk, m, \algo{Sign}(\params, \sk, m)) = 1] = 1
  \]
  where the probability is taken over the randomness of $\algo{Sign}$.
\end{definition}

In other words, a signature scheme is correct if honestly generated signatures always verify correctly.

\subsection{Security}

The standard security notion for digital signatures is existential unforgeability under chosen message attack (EUF-CMA). Unlike one-time signatures, the adversary can request signatures on multiple messages before attempting to forge.

\begin{definition}[EUF-CMA Security]\label{def:euf-cma}
  A digital signature scheme $\algo{Sig} = (\algo{Setup}, \algo{KeyGen}, \algo{Sign}, \algo{Verify})$ is \emph{existentially unforgeable under chosen message attack (EUF-CMA)} if for all \ppt adversaries $\adv$:
  \[
    \advantage{EUF-CMA}{\adv, \algo{Sig}} \defeq \pr{\game{\Game~\algo{EUF-CMA}}{\algo{Sig}} = 1} = \negl
  \]
  where $\game{\Game~\algo{EUF-CMA}}{\algo{Sig}}$ is defined in \autoref{fig:euf-cma-sig}.
\end{definition}

\begin{figure}[tbh]
  \begin{tcolorbox}
    \begin{pchstack}[center]
      \procedure{$\game{\Game~\algo{EUF-CMA}}{\algo{Sig}}$}{%
        \params \gets \algo{Setup}(1^\secpar) \\
        (\sk,\pk) \gets \algo{KeyGen}(\params) \\
        \mathcal{Q} \defeq \emptyset\\
        (m^*, \sigma^*) \gets \adv^{\pcoracle{Sign}}(\params, \pk) \\
        \pcreturn m^* \notin \mathcal{Q} \wedge \\
        \t \algo{Verify}(\params, \pk, m^*, \sigma^*) = 1
      }
      \pchspace
      \procedure{Oracle $\pcoracle{Sign}(m)$}{%
        \sigma \gets \algo{Sign}(\params, \sk, m) \\
        \mathcal{Q} \defeq \mathcal{Q} \cup \{m\} \\
        \pcreturn \sigma
      }
    \end{pchstack}
  \end{tcolorbox}
  \caption{The EUF-CMA security game for digital signatures}
  \label{fig:euf-cma-sig}
\end{figure}

\subsection{Schnorr Signatures}

\begin{definition}[Schnorr Signature Scheme]\label{def:schnorr}
  Let $\grgen$ be a group generation algorithm and $\algo{H}$ be a hash function. The Schnorr signature scheme $\algo{SchnorrSig}[\grgen, \algo{H}]$ is defined as follows:
  \begin{itemize}
    \item $\algo{Setup}(1^\secpar) \rightarrow \params$: Run $\gparam \gets \grgen(1^\secpar)$. The message space is $\mathcal{M} = \{0,1\}^*$ and the signature space is $\mathcal{S} = \GG \times \ZZ_p$. Output $\params = (\gparam, \mathcal{M}, \mathcal{S})$.
    
    \item $\algo{KeyGen}(\params) \rightarrow (\sk, \pk)$: Sample $x \sample \ZZ_p$. Compute $X = g^x$. Output $\sk = x$ and $\pk = X$.
    
    \item $\algo{Sign}(\params, \sk, m) \rightarrow \sigma$: Parse $\sk = x$. Sample $r \sample \ZZ_p$. Compute:
    \begin{align*}
      R &= g^r \\
      c &= \algo{H}(R \| m) \\
      s &= r + c \cdot x \bmod p
    \end{align*}
    Output $\sigma = (R, s)$.
    
    \item $\algo{Verify}(\params, \pk, m, \sigma) \rightarrow \{0, 1\}$: Parse $\pk = X$ and $\sigma = (R, s)$. Compute $c = \algo{H}(R \| m)$. Accept if and only if:
    \[
      g^s = R \cdot X^c
    \]
  \end{itemize}
\end{definition}

\begin{lemma}[Correctness of Schnorr Signatures]\label{lem:schnorr-correctness}
  The Schnorr signature scheme $\algo{SchnorrSig}[\grgen, \algo{H}]$ is correct.
\end{lemma}

\begin{proof}
  Let $\sigma = (R, s)$ be a signature generated by $\algo{Sign}(\params, \sk, m)$ where $\sk = x$ and $\pk = X = g^x$. By the signing algorithm, we have $R = g^r$ for some $r \sample \ZZ_p$, $c = \algo{H}(R \| m)$, and $s = r + c \cdot x \bmod p$. The verification equation holds because:
  \[
    g^s = g^{r + cx} = g^r \cdot g^{cx} = R \cdot (g^x)^c = R \cdot X^c
  \]
  Therefore, $\algo{Verify}(\params, \pk, m, \sigma) = 1$ for all honestly generated signatures.
\end{proof}


\begin{figure}[tbhp]
  \begin{center}
    \begin{tcolorbox}[width=\textwidth]
      \begin{pchstack}[center]
        \begin{pcvstack}
          \procedure[headlinesep=1pt]{$\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrSig}}$}{%
            \gparam \gets \grgen(1^\secpar) \\
            x \sample \ZZ_p \\
            X \defeq g^x \\
            \params \defeq (\gparam, \{0,1\}^*, \GG \times \ZZ_p) \\
            T \defeq \emptyset \\
            \mathcal{Q} \defeq \emptyset \\
            (m^*, \sigma^*) \gets \adv^{\pcoracle{Sign}, \pcoracle{H}}(\params, X) \\
            (R^*, s^*) \defeq \sigma^* \\
            c^* \defeq \pcoracle{H}(R^* \| m^*) \\
            \pcreturn m^* \notin \mathcal{Q} \wedge g^{s^*} = R^* \cdot X^{c^*}
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{Sign}(m)$}{%
            r \sample \ZZ_p \\
            R \defeq g^r \\
            c \defeq \pcoracle{H}(R \| m) \\
            s \defeq r + c \cdot x \bmod p \\
            \mathcal{Q} \defeq \mathcal{Q} \cup \{m\} \\
            \pcreturn (R, s)
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{H}(y)$}{%
            \pcif T[y] = \bot \pcthen \\
            \t T[y] \sample \ZZ_p \\
            \pcreturn T[y]
          }
        \end{pcvstack}
        \pchspace
        \begin{pcvstack}
          \procedure[headlinesep=1pt]{$\bdv(\gamechange{$\gparam, X;$} \rho)$}{%
            \gamechange{$\params \defeq (\gparam, \{0,1\}^*, \GG \times \ZZ_p)$} \\
            T \defeq \emptyset \\
            \mathcal{Q} \defeq \emptyset \\
            (m^*, \sigma^*) \gets \adv^{\pcoracle{Sign}_{\bdv}, \pcoracle{H}_{\bdv}}(\params, X; \rho) \\
            (R^*, s^*) \defeq \sigma^* \\
            c^* \defeq \pcoracle{H}_{\bdv}(R^* \| m^*) \\
            \gamechange{$\pcassert m^* \notin \mathcal{Q}$} \\
            \gamechange{$\pcassert g^{s^*} = R^* \cdot X^{c^*}$} \\
            \gamechange{$\pcreturn ((R^*, m^*), s^*)$}
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{Sign}_{\bdv}(m)$}{%
            \gamechange{$s \sample \ZZ_p$} \\
            \gamechange{$c \sample \ZZ_p$} \\
            \gamechange{$R \defeq g^s \cdot X^{-c}$} \\
            \gamechange{$\pcassert T[R \| m] = \bot$} \\
            \gamechange{$T[R \| m] \defeq c$} \\
            \mathcal{Q} \defeq \mathcal{Q} \cup \{m\} \\
            \pcreturn (R, s)
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{H}_{\bdv}(y)$}{%
            \pcif T[y] = \bot \pcthen \\
            \t T[y] \sample \ZZ_p \\
            \pcreturn T[y]
          }
        \end{pcvstack}
        \pchspace
        \begin{pcvstack}
          \procedure[headlinesep=1pt]{$\cdv^{\gamechange{$\pcoracle{H}$}}(\gparam, X; \rho)$}{%
            \params \defeq (\gparam, \{0,1\}^*, \GG \times \ZZ_p) \\
            T \defeq \emptyset \\
            \mathcal{Q} \defeq \emptyset \\
            (m^*, \sigma^*) \gets \adv^{\pcoracle{Sign}_{\cdv}, \pcoracle{H}_{\cdv}}(\params, X; \rho) \\
            (R^*, s^*) \defeq \sigma^* \\
            c^* \defeq \pcoracle{H}_{\cdv}(R^* \| m^*) \\
            \pcassert m^* \notin \mathcal{Q} \\
            \pcassert g^{s^*} = R^* \cdot X^{c^*} \\
            \pcreturn ((R^*, m^*), s^*)
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{Sign}_{\cdv}(m)$}{%
            s \sample \ZZ_p \\
            c \sample \ZZ_p \\
            R \defeq g^s \cdot X^{-c} \\
            \pcassert T[R \| m] = \bot \\
            T[R \| m] \defeq c \\
            \mathcal{Q} \defeq \mathcal{Q} \cup \{m\} \\
            \pcreturn (R, s)
          }
          \pcvspace
          \procedure[headlinesep=1pt]{Oracle $\pcoracle{H}_{\cdv}(y)$}{%
            \pcif T[y] = \bot \pcthen \\
            \gamechange{$\t T[y] \gets \pcoracle{H}(y)$} \\
            \pcreturn T[y]
          }
        \end{pcvstack}
      \end{pchstack}
    \end{tcolorbox}
  \end{center}
  \caption{Security reduction for Schnorr signatures: EUF-CMA game (left), algorithm $\bdv$ (middle), and algorithm $\cdv$ (right). Changes from the previous game are marked with $\gamechange{$\cdot$}$.}
  \label{fig:schnorr-reduction}
\end{figure}

\begin{lemma}\label{lem:schnorr-to-single}
  Let $\adv$ be an adversary against the EUF-CMA security of $\algo{SchnorrSig}[\grgen, \algo{H}]$ in the random oracle model for $\algo{H}$ making at most $q_s$ queries to $\pcoracle{Sign}$ and at most $q_h$ queries to $\algo{H}$.

  Let $\algo{InpGen}$ be the algorithm which on input $1^\secpar$ runs $(\GG, p, g) \gets \grgen(1^\secpar)$, draws $X \sample \GG$, and returns $((\GG, p, g), X)$.

  Consider algorithm $\cdv$ defined in \autoref{fig:schnorr-reduction} that takes as input $(\gparam, X) \gets \algo{InpGen}(1^\secpar)$ and has access to a random oracle $\algo{H}$. Then $\cdv$ makes at most $q_h + 1$ queries to $\algo{H}$, and satisfies
  \[
    \left|\advantage{Single}{\cdv, \algo{InpGen}} - \advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]}\right| \leq \frac{q_s(q_s + q_h)}{2^\secpar}
  \]
  with $\advantage{Single}{\cdv, \algo{InpGen}}$ as defined in the forking lemma (\autoref{lem:fork}).

  Moreover, when $\cdv$ returns a non-$\bot$ output $(z, \mathit{aux})$, then $z = (R^*, m^*)$, $\mathit{aux} = s^*$, and
  \[
    g^{s^*} = R^* \cdot X^{\algo{H}(R^* \| m^*)}
  \]
\end{lemma}

The proof is left as an exercise (see \autoref{ex:schnorr-to-single}).

\begin{theorem}[Schnorr signatures are EUF-CMA secure]\label{thm:schnorr-euf-cma}
  Let $\grgen$ be a group generation algorithm for which the discrete logarithm problem is hard and let $\algo{H}$ be a hash function.
  Then the Schnorr signature scheme $\algo{SchnorrSig}[\grgen, \algo{H}]$ is EUF-CMA secure in the random oracle model for $\algo{H}$.
  More precisely, for any \ppt adversary $\adv$ against the EUF-CMA security of $\algo{SchnorrSig}[\grgen, \algo{H}]$ making at most $q_s$ queries to the signing oracle and at most $q_h$ queries to the random oracle $\algo{H}$,
  there exists a \ppt adversary $\ddv$ against the discrete logarithm problem such that
  \[
    \advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]} \leq \frac{q_s(q_s + q_h)}{2^\secpar} + \sqrt{(q_h + 1) \left(\advantage{DLog}{\ddv, \grgen} + \frac{1}{2^\secpar}\right)}.
  \]
\end{theorem}

The proof is left as an exercise (see \autoref{ex:schnorr-euf-cma}).

\subsection{Exercises}

\begin{exercise}
  The EUF-CMA security definition in \autoref{def:euf-cma} only requires the forged message to be new. An alternative notion called \emph{strong EUF-CMA} would prevent the adversary from winning even if they produce a different signature for a message they previously queried. Define a strong EUF-CMA security game that captures this intuition.
\end{exercise}

\ifsolutions
\begin{mysolution}
  For strong EUF-CMA security, we modify the signing oracle to maintain a set of message-signature pairs:
  \begin{itemize}
    \item Initialize $\mathcal{Q} \defeq \emptyset$
    \item In oracle $\pcoracle{Sign}(m)$: compute $\sigma \gets \algo{Sign}(\params, \sk, m)$, set $\mathcal{Q} \defeq \mathcal{Q} \cup \{(m, \sigma)\}$, and return $\sigma$
    \item Winning condition: $(m^*, \sigma^*) \notin \mathcal{Q} \wedge \algo{Verify}(\params, \pk, m^*, \sigma^*) = 1$
  \end{itemize}

  The key difference from standard EUF-CMA is that $\mathcal{Q}$ stores pairs $(m, \sigma)$ rather than just messages, and the adversary must output a pair that was never returned by the signing oracle, even if the message component was queried before.
\end{mysolution}
\fi


\begin{exercise}
  In the Generic Group Model (GGM)~\cite{EC:Shoup97}, the advantage of solving the discrete logarithm problem with $q$ group operations is bounded by $\advantage{DLog}{\adv, \grgen} \leq \frac{q^2}{2p}$ where $p$ is the prime group order.
  
  Consider Schnorr signatures over a 256-bit elliptic curve group (e.g., secp256k1 where $p \approx 2^{256}$). Suppose an adversary can make:
  \begin{itemize}
    \item $q_s = 2^{10}$ signing queries
    \item $q_h = 2^{85}$ hash queries
    \item $q = 2^{85}$ group operations
  \end{itemize}
  
  Calculate the concrete EUF-CMA advantage using the bound from \autoref{thm:schnorr-euf-cma} with $\secpar = 256$, and compare it to the discrete logarithm advantage $\advantage{DLog}{\adv, \grgen}$ in the GGM.
\end{exercise}

\ifsolutions
\begin{mysolution}
  From \autoref{thm:schnorr-euf-cma}:
  \[
    \advantage{EUF-CMA}{\adv, \algo{SchnorrSig}} \leq \frac{q_s(q_s + q_h)}{2^\secpar} + \sqrt{(q_h + 1) \left(\advantage{DLog}{\ddv, \grgen} + \frac{1}{2^\secpar}\right)}
  \]
  
  First, let's calculate the discrete logarithm advantage in the GGM:
  \[
    \advantage{DLog}{\adv, \grgen} \leq \frac{q^2}{2p} = \frac{(2^{85})^2}{2^{257}} = \frac{2^{170}}{2^{257}} = 2^{-87}
  \]
  
  Now for the EUF-CMA advantage. First term:
  \[
    \frac{q_s(q_s + q_h)}{2^\secpar} \approx \frac{2^{10} \cdot 2^{85}}{2^{256}} = \frac{2^{95}}{2^{256}} = 2^{-161}
  \]
  
  Second term:
  \[
    \sqrt{(q_h + 1) \left(\advantage{DLog}{\ddv, \grgen} + \frac{1}{2^\secpar}\right)} \approx \sqrt{2^{85} \cdot 2^{-87}} = \sqrt{2^{-2}} = 2^{-1} = 0.5
  \]
  
  Therefore:
  \[
    \advantage{EUF-CMA}{\adv, \algo{SchnorrSig}} \leq 2^{-161} + 0.5 \approx 0.5
  \]
  
  \textbf{Comparison:} The discrete logarithm advantage is $2^{-87}$ (87 bits of security), while the EUF-CMA advantage for Schnorr signatures is approximately $0.5$ (less than 1 bit of security). 
  
  This dramatic difference—losing over 86 bits of security—is due to the square root loss in the forking lemma. 
  
  \textbf{Remark:} In the Algebraic Group Model (AGM)~\cite{C:FucKilLos18}, Schnorr signatures can be proven secure with a much tighter reduction. The AGM assumes that whenever an adversary outputs a group element, it must also provide an algebraic representation in terms of previously seen group elements. Because the AGM proof doesn't require rewinding (unlike the forking lemma), it avoids the square root loss entirely, achieving security that nearly matches the hardness of discrete logarithm.
\end{mysolution}
\fi

\begin{exercise}\label{ex:schnorr-to-single}
  Prove \autoref{lem:schnorr-to-single} using the games in \autoref{fig:schnorr-reduction}.
\end{exercise}

\ifsolutions
\begin{mysolution}
  We prove the lemma by a sequence of game hops between the three games in \autoref{fig:schnorr-reduction}.

  \paragraph{From $\Game~\algo{EUF\text{-}CMA}$ to $\game{\algo{Single}}{\algo{InpGen}}[\bdv]$}
  The main differences are:
  \begin{itemize}
    \item $\bdv$ receives $((\GG, p, g), X)$ from $\algo{InpGen}(1^\secpar)$ instead of generating the key pair $(x, X)$.
    \item The signing oracle $\pcoracle{Sign}_{\bdv}$ simulates signing without knowing $x$ by programming the random oracle.
    \item $\bdv$ explicitly asserts the winning conditions of $\Game~\algo{EUF\text{-}CMA}$, and outputs $((R^*, m^*), s^*)$.
  \end{itemize}

  Let $E$ be the event that $\bdv$ aborts during a signing oracle query(i.e., $T_{\bdv}[R  m] \neq \bot$).
  We now prove that that $\pr{\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrSig}} = 1}$ is equal to $\pr{\game{\algo{Single}}{\algo{InpGen}}[\bdv] = 1}$ if $E$ does not occur.
  \begin{itemize}
    \item $\algo{InpGen}(1^\secpar)$ outputs $((\GG, p, g), X)$ where $X \sample \GG$, which has the same distribution as the key generation in $\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrSig}}$ since $X = g^x$ for uniformly random $x \sample \ZZ_p$.
    \item The signatures output by the signing oracle have the same distribution in both games when event $E$ does not occur. To see why, let's examine how signatures are generated:
    \begin{itemize}
      \item In $\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrSig}}$: Sample $r \sample \ZZ_p$, compute $R = g^r$, set $c = \algo{H}(R \| m)$, and output $(R,
  s)$ where $s = r + x \cdot c$
      \item In $\bdv$: Sample $(c, s) \sample \ZZ_p \times \ZZ_p$, compute $R = g^s \cdot X^{-c}$, program $T_{\bdv}[R \| m] = c$, and output $(R, s)$
    \end{itemize}

    Both methods produce signatures satisfying the verification equation $g^s = R \cdot X^c$. The key insight is that:
    \begin{itemize}
      \item In the EUF-CMA game: Starting from uniform $r$, we get uniform $R \in \GG$ and compute $s$ deterministically
      \item In $\bdv$: Starting from uniform $(c, s)$, we compute $R$ deterministically to satisfy the same equation
    \end{itemize}

    Since there's a bijection between the randomness and valid signatures in both cases, and the oracle programming ensures $c = \algo{H}(R \| m)$ when
  queried, both games produce identical signature distributions when $E$ does not occur.
  \item The programmed oracle $\pcoracle{H}_{\bdv}$ is indistinguishable from the real random oracle $\pcoracle{H}$ when $E$ does not occur. The oracle
  $\pcoracle{H}_{\bdv}$ returns either programmed values (for queries $R \| m$ where $(R, s)$ was output by $\pcoracle{Sign}_{\bdv}(m)$) or fresh random
  values from $\pcoracle{H}$. Since programmed values are chosen uniformly at random when signatures are created, all oracle responses are uniformly
  distributed in $\ZZ_p$. The adversary can only distinguish between $\pcoracle{H}_{\bdv}$ and $\pcoracle{H}$ if it queries $\pcoracle{H}_{\bdv}(R \| m)$
  before $\pcoracle{Sign}_{\bdv}(m)$ happens to generate the same $R$ – but this is precisely event $E$.
  \end{itemize}

  Thus we conclude that
  \[
    \pr{\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrSig}} = 1 \wedge \neg E} =  \pr{\game{\algo{Single}}{\algo{InpGen}}[\bdv] = 1 \wedge \neg E}
  \] and by the Difference Lemma (\autoref{lem:difference}) we have
  \[
    |\pr{\game{\Game~\algo{EUF-CMA}}{\algo{SchnorrSig}} = 1} - \pr{\game{\algo{Single}}{\algo{InpGen}}[\bdv] = 1}| \leq \Pr[E]
  \].

  To bound the probability of event $E$, we first observe that when event $E$ occurs there exists a key $(R', m')$ in $T_{\bdv}$ such that $R'$ is equal to value $R$ computed in the signing oracle.
  The probability that $R$ equals a specific $R'$ is $1/|\GG|$ since $R$ is uniformly distributed in $\GG$: for any $R \in \GG$ and any $s \in \ZZ_p$, there is exactly one $c \in \ZZ_p$ such that $R = g^s \cdot X^{-c}$.
  Moreover, at the time of each signing query, the table $T_{\bdv}$ contains at most $q_s + q_h$ entries (from previous signing queries and hash queries).
  Therefore, the probability that $R \| m$ matches any existing entry in $T_{\bdv}$ is at most $\frac{q_s + q_h}{|\GG|}$.

  By union bound over all $q_s$ signing queries:
  \[
    \Pr[E] \leq \frac{q_s(q_s + q_h)}{|\GG|} \leq \frac{q_s(q_s + q_h)}{2^\secpar}
  \]

  \paragraph{From Algorithm $\bdv$ to Algorithm $\cdv$}
  The only difference between $\bdv$ and $\cdv$ is that $\cdv$ has access to an external random oracle $\pcoracle{H}$, and uses a modified oracle $\pcoracle{H}_{\cdv}$ that:
  \begin{itemize}
    \item Returns the programmed value $T[y]$ if it exists
    \item Otherwise queries the external oracle $\pcoracle{H}(y)$
  \end{itemize}

  This is a purely syntactic change. In $\bdv$, non-programmed queries sample fresh randomness directly; in $\cdv$, they get it from the external oracle.
  Since both sources provide independent uniform values from $\ZZ_p$, the adversary's view is identical. Therefore:
  \[
    \Pr[\game{\algo{Single}}{\algo{InpGen}}[\bdv] = 1] = \Pr[\game{\algo{Single}}{\algo{InpGen}}[\cdv] = 1]
  \]

  \paragraph{Conclusion.}
  Finally, we need to prove that when $\cdv$ succeeds (i.e., doesn't abort), the output satisfies $g^{s^*} = R^* \cdot X^{\algo{H}(R^* \| m^*)}$ where $\algo{H}$ is the external oracle. We know that $g^{s^*} = R^* \cdot X^{c^*}$ where $c^* = \pcoracle{H}_{\cdv}(R^* \| m^*)$. We claim that $\pcoracle{H}_{\cdv}(R^* \| m^*) = \pcoracle{H}(R^* \| m^*)$.
  
  Assume for contradiction that $\pcoracle{H}_{\cdv}(R^* \| m^*) \neq \pcoracle{H}(R^* \| m^*)$. This means $T[R^* \| m^*] \neq \pcoracle{H}(R^* \| m^*)$, so $T[R^* \| m^*]$ must have been assigned during a $\pcoracle{Sign}_{\cdv}$ query. But whenever $\pcoracle{Sign}_{\cdv}$ sets $T[R \| m] = c$, it also adds $m$ to $\mathcal{Q}$. Therefore $m^* \in \mathcal{Q}$. However, $\cdv$ asserts that $m^* \notin \mathcal{Q}$, which is a contradiction. Thus $c^* = \pcoracle{H}(R^* \| m^*)$.
  
  Combining the bounds:
  \[
    \left|\advantage{Single}{\cdv, \algo{InpGen}} - \advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]}\right| \leq \frac{q_s(q_s + q_h)}{2^\secpar}
  \]

\end{mysolution}
\fi

\begin{exercise}\label{ex:schnorr-euf-cma}
  Prove \autoref{thm:schnorr-euf-cma}. Use \autoref{lem:schnorr-to-single} and the forking lemma (\autoref{lem:fork}).
\end{exercise}

\ifsolutions
\begin{mysolution}
  We construct an algorithm $\ddv$ that solves the discrete logarithm problem using a successful EUF-CMA adversary $\adv$ against Schnorr signatures.
  
  Given a discrete logarithm instance $((\GG, p, g), X)$ where $X = g^x$ for unknown $x$, algorithm $\ddv$ works as follows:
  \begin{enumerate}
    \item Run the forking game $\game{\algo{Fork}}{\algo{InpGen}}[\cdv]$ with algorithm $\cdv$ from \autoref{lem:schnorr-to-single}
    \item If the forking game returns $((R^*, m^*), s_1, (R^*, m^*), s_2) \neq \bot$, then we have:
    \begin{itemize}
      \item From the first execution: By \autoref{lem:schnorr-to-single}, we have $g^{s_1} = R^* \cdot X^{h_1}$ where $h_1 = \algo{H}(R^* \| m^*)$
      \item From the second execution: By \autoref{lem:schnorr-to-single}, we have $g^{s_2} = R^* \cdot X^{h_2}$ where $h_2 = \algo{H}'(R^* \| m^*)$
      \item By the assertion $T[z] \neq T'[z]$ in $\game{\algo{Fork}}{\algo{InpGen}}$ with $z = (R^* \| m^*)$: we have $h_1 \neq h_2$
    \end{itemize}
    \item From the two verification equations:
    \[
      g^{s_1} = R^* \cdot X^{h_1} \text{ and } g^{s_2} = R^* \cdot X^{h_2}
    \]
    Dividing the first by the second:
    \[
      g^{s_1 - s_2} = X^{h_1 - h_2}
    \]
    \item Since $h_1 \neq h_2$ and we work in $\ZZ_p$, we can compute:
    \[
      x = \frac{s_1 - s_2}{h_1 - h_2} \bmod p
    \]
    \item Output $x$
  \end{enumerate}
  
  \textbf{Success Probability:} Algorithm $\ddv$ succeeds in solving the discrete logarithm problem exactly when the forking game returns non-$\bot$ outputs. Therefore:
  \[
    \advantage{DLog}{\ddv, \grgen} = \advantage{Fork}{\cdv, \algo{InpGen}}
  \]
  
  By the forking lemma:
  \begin{align*}
    \advantage{Fork}{\cdv, \algo{InpGen}} &\geq \advantage{Single}{\cdv, \algo{InpGen}} \left( \frac{\advantage{Single}{\cdv, \algo{InpGen}}}{q_h + 1} - \frac{1}{2^\secpar} \right)\\
    &\geq  \frac{\advantage{Single}{\cdv, \algo{InpGen}}^2}{q_h + 1} - \frac{1}{2^\secpar}\\
  \end{align*}
  because $\advantage{Single}{\cdv, \algo{InpGen}} \leq 1$.
  
  By \autoref{lem:schnorr-to-single}, we have:
  \[
    \left|\advantage{Single}{\cdv, \algo{InpGen}} - \advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]}\right| \leq \frac{q_s(q_s + q_h)}{2^\secpar}
  \]
  
  This means:
  \[
    \advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]} - \frac{q_s(q_s + q_h)}{2^\secpar} \leq \advantage{Single}{\cdv, \algo{InpGen}} \leq \advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]} + \frac{q_s(q_s + q_h)}{2^\secpar}
  \]
  
  Therefore:
  \begin{align*}
    \advantage{DLog}{\ddv, \grgen} &\geq \frac{\advantage{Single}{\cdv, \algo{InpGen}}^2}{q_h + 1} - \frac{1}{2^\secpar}\\
    &\geq \frac{\left(\advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]} - \frac{q_s(q_s + q_h)}{2^\secpar}\right)^2}{q_h + 1} - \frac{1}{2^\secpar}
  \end{align*}
  
  Rearranging:
  \[
    (q_h + 1) \left(\advantage{DLog}{\ddv, \grgen} + \frac{1}{2^\secpar}\right) \geq \left(\advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]} - \frac{q_s(q_s + q_h)}{2^\secpar}\right)^2
  \]
  
  Therefore:
  \[
    \advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]} \leq \frac{q_s(q_s + q_h)}{2^\secpar} + \sqrt{(q_h + 1) \left(\advantage{DLog}{\ddv, \grgen} + \frac{1}{2^\secpar}\right)}
  \]
  
  $q_s, q_h$ are polynomial in $\secpar$ since $\adv$ is \ppt
  Assuming the discrete logarithm problem is hard (i.e., $\advantage{DLog}{\ddv, \grgen}$ is negligible), we conclude that $\advantage{EUF-CMA}{\adv, \algo{SchnorrSig}[\grgen, \algo{H}]}$ is negligible.
\end{mysolution}
\fi
